/*
Biblioteca com funções uteis para Monte Carlo e Modelo de Ising-2D
*/
#include"lib.h"

double uniform(double min, double max) {
    /*
    Função que gera um número aleatório em uma distribuição uniforme
    Para int: [min, max)
    */
    double random  = ((double) rand()) / RAND_MAX;
    double range = (max - min) * random;
    double n = range + min;	
    
    return n;
}

int **vizinhos(int l){
    int n = l*l;
    int **mtzviz = (int **)malloc(n*sizeof(int*));
    for(int ni = 0; ni < n; ++ni){
        mtzviz[ni] = (int *)malloc(4*sizeof(int));
    }
    /*
    mtzviz[0] - Direita
    mtzviz[1] - Cima
    mtzviz[2] - Esquerda
    mtzviz[3] - Baixo
    */

    for(int i = 0; i < n; ++i){  
        // ultima coluna, deslocamos  L-1
        if(i%l == l-1) mtzviz[i][0] = i + 1 - l;
        else mtzviz[i][0] = i + 1;
        // primeira coluna, somamos L-1
        if(i%l == 0) mtzviz[i][2] = i - 1 + l;
        else mtzviz[i][2] = i - 1;
        // primeira linha, somamos N-L
        if(i<l) mtzviz[i][1] = i - l + n;
        else mtzviz[i][1] = i - l;
        // ultima linha, modulo L
        if(i>=n-l) mtzviz[i][3] = (i % l);
        else mtzviz[i][3] = i + l;
    }
    
    return mtzviz;
}

void defexp(double *expBeta, double beta){
   expBeta[0] = exp(-beta*0);
   expBeta[1] = exp(-beta*4);
   expBeta[2] = exp(-beta*8);
}

void metropolis(int *sis, int **viz, double *E, double *expBeta, int J, int j){
    int dE = 2*J*sis[j]*(sis[viz[j][0]] + sis[viz[j][1]] + sis[viz[j][2]] + sis[viz[j][3]]);
    if((dE < 0) || (uniform(0., 1.) < expBeta[dE/4])){
        sis[j] *= -1;
        *E += dE;
    }
}

int energia(int *sis, int **viz, int n, int j){
    /*
    Função que calcula a energia do sistema
    */
    int en = 0;
    for(int i = 0; i < n; ++i) en += sis[i]*(sis[viz[i][0]] + sis[viz[i][3]]);
    return -j*en;
}

double magnetizacao(int *sis, int n){
    /*
    Função que calcula a magnetização so sistema
    */
    double m = 0;
    for(int i = 0; i < n; ++i) m += sis[i];
    return m/n;
}

double corrtemp(int *s0, int *st, double m0, double mt, int n){
    /*
    Função que mede a correlação temporal no tempo  t do sistema
    */
    double C = 0;
    for(int i = 0; i < n; ++i){
        C += s0[i]*st[i];
    }
    C /= n;
    C -= m0*mt;
    return C;
}

void corresp(double *crr, int *s, int **viz, int n, int l, double m){
    /*
    Função que mede a correlação espacial do sistema
    */
    double c = 0;
    int vv, vh;
    for(int i = 0; i < n; ++i){
        vv = viz[i][3];
        vh = viz[i][0];
        for(int li = 0; li < l/2; ++li){
            c = s[i]*(s[vh] + s[vv]);
            vv = viz[vv][3];
            vh = viz[vh][0];
            crr[li] += c; 
        }
    }
    for(int li = 0; li < l/2; ++li){
        crr[li] /= 2*n;
        //crr[l] -= m*m;
    }
}


void hoshenkopelman(int *sis, int **viz, int *hk, int N){

    // First assignment of values
    for(int i = 0; i < N; ++i){
        hk[i] = i;
    }

    printf("Dentro da função\n");

    for(int i = 0; i < N; ++i){
        printf("To no %d\n", i);
        if(sis[i] == sis[viz[i][1]]) unionfind(i, viz[i][1], hk, viz, 1);
        if(sis[i] == sis[viz[i][2]]) unionfind(i, viz[i][2], hk, viz, 2);
    }
}


void unionfind(int i, int j, int *hk, int **viz, int dir){
    int rdir;
    switch(dir){
        case 1:
            rdir = 3;
        break;
        case 2:
            rdir = 0;
        break;
    }

    if(hk[i] > hk[j]){
        recurlabel(hk, viz, i, hk[i], hk[j], dir);
        printf("ooooi\n");
    }
    else{
        recurlabel(hk, viz, j, hk[j], hk[i], rdir);       
        printf("oiiii\n");
    }

}


void recurlabel(int *hk, int **viz, int i, int labeli, int labelf, int dir){
    printf("in hk[%d] = %d\n", i, hk[i]);
    if(hk[viz[i][0]] == labeli && dir != 0) recurlabel(hk, viz, viz[i][0], labeli, labelf, 2);

    if(hk[viz[i][1]] == labeli && dir != 1) recurlabel(hk, viz, viz[i][1], labeli, labelf, 3);

    if(hk[viz[i][2]] == labeli && dir != 2) recurlabel(hk, viz, viz[i][2], labeli, labelf, 0);

    if(hk[viz[i][3]] == labeli && dir != 3) recurlabel(hk, viz, viz[i][3], labeli, labelf, 1);

    hk[i] = labelf;
    printf("out of %d\n", i);
}




/*void hoshenkopelman(int **viz, int *sis, int *hksis, int l){
    // Rotula clusters de spins +1 e -1
    int n = l*l;
    int labeli, labelf, newlabel = 0;

    for(int i = 0; i < n; ++i){
        // Se somente o vizinho de cima pode compartilhar cluster
        if(sis[i] == sis[viz[i][1]] && sis[i] != sis[viz[i][2]]){
            hksis[i] = (hksis[viz[i][1]] != 0) ? hksis[viz[i][1]] : ++newlabel;           
        }

        // Se somente o vizinho da esquerda pode compartilhar cluster
        if(sis[i] != sis[viz[i][1]] && sis[i] == sis[viz[i][2]]){
            hksis[i] = (hksis[viz[i][2]] != 0) ? hksis[viz[i][2]] : ++newlabel;           
        }

        // Se nenhum vizinho pode compartilhar cluster
        if(sis[i] != sis[viz[i][1]] && sis[i] == sis[viz[i][2]]) hksis[i] = ++newlabel;
        
        // Se ambos vizinhos podem ocupar o mesmo cluster
        if(sis[i] == sis[viz[i][1]] && sis[i] == sis[viz[i][2]]){
            // Se os dois vizinhos tem label igual
            if(hksis[viz[i][1]] == hksis[viz[i][2]] && hksis[viz[i][1]] != 0) hksis[i] = hksis[viz[i][1]];
    
            // Se os dois vizinhos tem label diferente
            if(hksis[viz[i][1]] != hksis[viz[i][2]] && hksis[viz[i][1]] != 0 && hksis[viz[i][2]] != 0){
                labeli = (hksis[viz[i][1]] < hksis[viz[i][2]]) ? hksis[viz[i][1]] : hksis[viz[i][2]];
                labelf = (hksis[viz[i][1]] > hksis[viz[i][2]]) ? hksis[viz[i][2]] : hksis[viz[i][1]];
                for(int j = 0; j < i; ++j) if(hksis[j] == labeli) hksis[j] = labelf;
            }

            // Se somente o vizinho de cima tem label
            if(hksis[viz[i][1]] != 0 && hksis[viz[i][2]] == 0) hksis[i] = hksis[viz[i][1]];

            // Se somente o vizinho da esquerda tem label
            if(hksis[viz[i][1]] == 0 && hksis[viz[i][2]] != 0) hksis[i] = hksis[viz[i][2]];

            // Se nenhum vizinho tem label
            if(hksis[viz[i][1]] == 0 && hksis[viz[i][2]] == 0) hksis[i] = ++newlabel;
        }
    }
}*/
